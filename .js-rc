#!/usr/bin/env bash

# Node helpers
export jsh="$(dirname "${BASH_SOURCE[0]}")/js-helpers"

export PATH="$PATH:$HOME/node_modules/.bin"
export PATH="$PATH:node_modules/.bin"

if which brew &> /dev/null; then
  export NVM_DIR=~/.nvm
  nvm_dir="$(brew --prefix nvm)"
  if [ -d "$nvm_dir" ]; then
    . "$nvm_dir/nvm.sh"
  fi
fi

defn nr npm run

defn npi npm i
defn npl npm ls
defn npln npm link

defn pni npm i
defn pnl npm ls
defn pnln npm link

defn ppj pretty-print-json
pretty_print_json_inplace() {
    tmp="$(mktemp)"
    for arg in "$@"; do
        cat "$arg" | jq . > "$tmp"
        mv "$tmp" "$arg"
    done
}
export -f pretty_print_json_inplace
defn ppji pretty_print_json_inplace
defn pji pretty_print_json_inplace
defn pjl pretty-print-json-less
defn jql pretty-print-json-less

defn jq. jq .
defn jf jq -f
defn jqf jq -f
defn jr jq -r
defn jqr jq -r
defn jqrs jq -rs
defn jqs jq -s
defn jqc jq -c
defn jqn jq length
jq_keys() {
    jq -r 'keys[]' "$@"
}
export -f jq_keys
defn jqk jq_keys

jq_lines_to_array() {
    jq -nR '[inputs | select(length>0)]' "$@"
}
export -f jq_lines_to_array
defn jql2a jq_lines_to_array

jq_lines_to_numbers() {
    jq_lines_to_array "$@" | jq 'map(tonumber)'
}
export -f jq_lines_to_numbers
defn jql2n jq_lines_to_numbers

sum() {
    jq_lines_to_numbers "$@" | jq add
}
export -f sum

human_readable_sum() {
    col="${1:-1}"
    awk "{ print \$$col }" | numfmt --from=iec | sum | numfmt --to=iec
}
export -f human_readable_sum
defn hsum human_readable_sum
defn hsum2 human_readable_sum 2
defn hsum3 human_readable_sum 3
defn hrs human_readable_sum
defn hrs2 human_readable_sum 2
defn hrs3 human_readable_sum 3

max() {
    jq_lines_to_numbers "$@" | jq max
}
export -f max

min() {
    jq_lines_to_numbers "$@" | jq min
}
export -f min

singleton() {
    jq -e "if (. | length) == 1 then .[0] else null end" "$@"
}
export -f singleton
defn jq1 singleton
defn j1 singleton
defn s1 singleton

keys() {
    jq -r 'keys[]' "$@"
}
export -f keys
defn ks keys

defn len jq length
defn jlen jq length

defn nrb npm run build
defn nrd npm run dev
defn nrdk npm run docker
defn nrl npm run lint
defn nrt npm run test
defn nrx npm run export

defn nxd next dev
defn nb next build
defn nxb next build
defn nx next export
defn nxx next export
next_build_export() {
    next build && next export "$@"
}
export -f next_build_export
defn nbx next_build_export
defn nxbx next_build_export

declare_module() {
    m="$1"; shift
    d="node_modules/@types/$m"
    mkdir -p "$d"
    echo "declare module '$m';" > "$d/index.d.ts"
}
export -f declare_module
defn dm declare_module

defn p2j parquet2json
defn p2js parquet-2-json.sh schema
defn p2jn parquet-2-json.sh rowcount
defn p2jc parquet-2-json.sh cat
defn p2jcc parquet-2-json.sh cat -c
defn p2jcl parquet-2-json.sh cat -l
defn p2jcl1 parquet-2-json.sh cat -l 1
defn p2jcn parquet-2-json.sh cat -l

parquet_pretty_print_n() {
    if [ $# -eq 0 ] || [ $# -gt 2 ]; then
        echo "Usage: $0 <n> [path]" >&2
        return 1
    fi
    n="$1"; shift
    if [ $# -eq 0 ]; then
        parquet2json <(cat) cat -l $n | jq .
    else
        parquet2json "$1" cat -l $n | jq .
    fi
}
export -f parquet_pretty_print_n
defn p2jcnq parquet_pretty_print_n

defn y yarn
defn yb yarn build
defn yi yarn install

defn yr yq -r

defn cna npx create-next-app
defn cnat npx create-next-app --ts
defn cnatn npx create-next-app --ts --use-npm
defn cnatp npx create-next-app --ts --use-pnpm
